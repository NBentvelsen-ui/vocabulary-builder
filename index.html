<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vocabulary Builder</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
        import React, { useState, useEffect } from 'react';
        import { X, Plus, BookOpen, Search, Loader } from 'lucide-react';

        function exportToExcel(words) {
            const header = ["Word","Meaning","Sentence","Synonyms","Category"]; 
            const rows = words.map(w => [w.word, w.meaning, w.sentence || "", w.synonyms || "", w.category || ""]);

            let csvContent = "data:text/csv;charset=utf-8,";
            csvContent += header.join(",") + "\n";
            rows.forEach(r => { csvContent += r.join(",") + "\n"; });

            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", "vocabulary_export.csv");
            document.body.appendChild(link);
            link.click();
        }

        export default function VocabularyBuilder() {
          const [words, setWords] = useState([]);
          const [loading, setLoading] = useState(true);
          const [showForm, setShowForm] = useState(false);
          const [selectedWord, setSelectedWord] = useState(null);
          const [selectedCategory, setSelectedCategory] = useState('All');
          const [searchTerm, setSearchTerm] = useState('');
          const [formData, setFormData] = useState({ word:'', meaning:'', sentence:'', synonyms:'', category:'' });

          useEffect(() => { loadWords(); }, []);

          const loadWords = async () => {
            try {
              setLoading(true);
              const result = await window.storage.list('word:', false);

              if (result && result.keys && result.keys.length > 0) {
                const loadedWords = [];
                for (const key of result.keys) {
                  try {
                    const data = await window.storage.get(key, false);
                    if (data && data.value) loadedWords.push(JSON.parse(data.value));
                  } catch {}
                }
                setWords(loadedWords);
              } else {
                const exampleWords = [
                  { id: Date.now(), word:'Ephemeral', meaning:'Lasting a short time', sentence:'', synonyms:'', category:'Adjectives' },
                  { id: Date.now()+1, word:'Serendipity', meaning:'Happy accident', sentence:'', synonyms:'', category:'Nouns' }
                ];
                for (const w of exampleWords) {
                  await window.storage.set(`word:${w.id}`, JSON.stringify(w), false);
                }
                setWords(exampleWords);
              }
            } finally {
              setLoading(false);
            }
          };

          const categories = ['All', ...new Set(words.map(w => w.category).filter(Boolean))];

          const handleSubmit = async (e) => {
            e.preventDefault();
            if (!formData.word || !formData.meaning) return;
            const newWord = { ...formData, id: Date.now() };
            await window.storage.set(`word:${newWord.id}`, JSON.stringify(newWord), false);
            setWords([...words, newWord]);
            setShowForm(false);
            setFormData({ word:'', meaning:'', sentence:'', synonyms:'', category:'' });
          };

          const handleDelete = async (id) => {
            await window.storage.delete(`word:${id}`, false);
            setWords(words.filter(w => w.id !== id));
            setSelectedWord(null);
          };

          const filteredWords = words.filter(w => {
            const matchesCategory = selectedCategory === 'All' || w.category === selectedCategory;
            const matchesSearch = w.word.toLowerCase().includes(searchTerm.toLowerCase()) || w.meaning.toLowerCase().includes(searchTerm.toLowerCase());
            return matchesCategory && matchesSearch;
          });

          if (loading) {
            return (<div className="min-h-screen flex items-center justify-center">Loading...</div>);
          }

          return (
            <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-50 p-6 pb-32">
              <div className="max-w-6xl mx-auto">

                <div className="text-center mb-8">
                  <div className="flex items-center justify-center gap-3 mb-2">
                    <BookOpen className="w-10 h-10 text-indigo-600" />
                    <h1 className="text-4xl font-bold text-gray-800">Vocabulary Builder</h1>
                  </div>
                  <button
                    onClick={() => exportToExcel(words)}
                    className="mt-4 bg-green-600 text-white px-4 py-2 rounded-lg hover:bg-green-700"
                  >
                    Export to Excel
                  </button>
                </div>

                <div className="mb-6 flex justify-center">
                  <div className="inline-flex gap-2 bg-white rounded-lg shadow-sm p-2 flex-wrap">
                    {categories.map(cat => (
                      <button key={cat} onClick={() => setSelectedCategory(cat)} className={`px-4 py-2 rounded-md font-medium ${selectedCategory===cat?'bg-indigo-600 text-white':'text-gray-600 hover:bg-gray-100'}`}>{cat}</button>
                    ))}
                  </div>
                </div>

                <div className="flex flex-wrap gap-3 justify-center mb-6">
                  {filteredWords.map((word)=>(
                    <button key={word.id} onClick={()=>setSelectedWord(word)} className="px-4 py-2 bg-white text-indigo-600 rounded-full shadow-sm hover:scale-105">{word.word}</button>
                  ))}
                </div>

                {/* Detail Modal */}
                {selectedWord && (
                  <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4" onClick={()=>setSelectedWord(null)}>
                    <div className="bg-white rounded-xl p-6 w-full max-w-lg" onClick={(e)=>e.stopPropagation()}>
                      <h3 className="text-3xl font-bold text-indigo-600 mb-2">{selectedWord.word}</h3>
                      <p className="text-gray-700">{selectedWord.meaning}</p>
                      <button className="mt-6 w-full py-2 text-red-600" onClick={()=>handleDelete(selectedWord.id)}>Delete</button>
                    </div>
                  </div>
                )}

                {/* Add Word Button */}
                <div className="fixed bottom-0 left-0 right-0 bg-white p-4 border-t">
                  <div className="max-w-6xl mx-auto flex gap-3">
                    <div className="relative flex-1">
                      <Search className="absolute left-3 top-1/2 -translate-y-1/2 text-gray-400 w-5 h-5" />
                      <input type="text" value={searchTerm} onChange={(e)=>setSearchTerm(e.target.value)} className="w-full pl-10 pr-4 py-3 border rounded-lg" placeholder="Search words..." />
                    </div>
                    <button onClick={()=>setShowForm(true)} className="bg-indigo-600 text-white px-6 py-3 rounded-lg">+ Add Word</button>
                  </div>
                </div>

              </div>
            </div>
          );
        }

        ReactDOM.createRoot(document.getElementById("root")).render(<VocabularyBuilder />);
    </script>
</body>
</html>
